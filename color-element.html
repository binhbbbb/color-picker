<link rel="import" href="../polymer/polymer-element.html">

<link rel="import" href="../input-picker-pattern/input-picker-shared-style.html">

<link rel="import" href="../color-input/color-badge.html">

<script>
  /**
   * Mixin for color-element
   *
   * @appliesMixin ColorBadgePattern
   *
   * @mixinFunction
   * @polymer
   */
  const ColorElementPattern = superClass => class extends ColorBadgePattern(superClass) { // eslint-disable-line no-unused-vars, no-undef

    static get styleToInclude() {
      return `${super.styleToInclude || '' } input-picker-shared-style`;
    }

    static get styleTemplate() {
      return `
        ${super.styleTemplate || ''}
        #colorElement {
          color: var(--input-picker-color);
          background-color: var(--input-picker-background);
          border-radius: var(--input-picker-border-radius);
          padding: var(--input-picker-padding);
          @apply --input-picker;
          display: -ms-inline-flexbox;
          display: -webkit-inline-flex;
          display: inline-flex;
          flex-flow: column nowrap;
          @apply --color-element;
        }
        #colorElement .selectors {
          display: inline-flex;
          flex-direction: row;
        }
        #colorElement .selectors > * {
          position: relative;
          margin-left: var(--input-picker-padding);
          height: var(--color-badge-height, 184px);
          width: var(--color-slider-width, 16px);
        }
        #colorElement #colorBadge {
          margin-left: 0;
          border-radius: 0;
          cursor: crosshair;
          background: transparent;
          box-shadow: none;
          width: var(--color-badge-width, 184px)
        }
        #colorElement .selectors > * {
          cursor: crosshair;
        }
        #colorElement .selectors .selector {
          position: absolute;
          box-sizing: border-box;
          border: thin solid currentColor;
          cursor: var(--color-selector-cursor, pointer);
        }
        #colorElement .selectors canvas {
          pointer-events: all;
        }
        #colorElement .selectors .selector:focus {
          outline: none;
          color: var(--inner-input-focus-background);
          background: var(--inner-input-focus-color);
        }
        #colorElement .selectors .selector.grabbing {
          cursor: -webkit-grabbing;
          cursor: grabbing;
        }
        #colorElement .selectors .pin {
          top: -3px;
          left: -3px;
          padding: 3px;
          border-radius: 50%;
        }
        #colorElement .selectors .slider {
          top: -2px;
          left: 0;
          padding: 2px;
          width: 100%;
          border-radius: 2px;
        }
        #colorElement #buttons {
          display: inline-flex;
          flex-direction: row;
          position: relative;
          align-items: flex-end;
          align-self: stretch;
          flex: 0 0 auto;
          margin-top: var(--input-picker-padding);
        }
        #colorElement #buttons #formats {
          align-self: stretch;
        }
      `;
    }

    static get colorElementTemplate() {
      return `
        <div id="colorElement">
          <div class="selectors">
            ${this.colorBadgeTemplate}
            <div id="alphaBadge" class="transparency" style="background:#fff;">
              <canvas id="alpha" prop="alpha" width="[[_sliderwidth]]" height="[[_badgeheight]]" on-click="_select" on-drop="_select"></canvas>
              <button id="alphaSlider" prop="alpha" class="selector slider" hidden$="[[!_valueIsSet]]" draggable="true" on-drag="_select" on-dragend="_select"></button>
            </div>
            <div id="hueBadge">
              <canvas id="hue" prop="hue" width="[[_sliderwidth]]" height="[[_badgeheight]]" on-click="_select" on-drop="_select"></canvas>
              <button id="hueSlider" prop="hue" class="selector slider" hidden$="[[!_valueIsSet]]" draggable="true" on-drag="_select" on-dragend="_select"></button>
            </div>
          </div>
          <div id="buttons">
            ${this.buttonTemplate}
          <div>
        </div>
      `
    }

    static get colorBadgeTemplate() {
      return `
        <div id="colorBadge">
          <canvas id="badge" width$="[[_badgewidth]]" height$="[[_badgeheight]]" on-click="_select" on-drop="_select"></canvas>
          <button id="colorPin" class="selector pin" hidden$="[[!_valueIsSet]]" draggable="true" on-drag="_select" on-dragend="_select"></button>
        </div>
      `;
    }

    /**
     * template for control buttons
     * @type {string}
     */
    static get buttonTemplate() {
      return `
        <div style="flex:1;"></div>
        <button class="icon random" on-click="random"><svg viewBox="0 0 24 24"><g><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></g></svg></button>
        ${super.buttonTemplate || ''}
      `;
    }

    static get observers() {
      return [
        '_drawHue(_sliderwidth, _badgeheight)',
        '_drawAlpha(h, _sliderwidth, _badgeheight)',
        '_moveColorPin(s, l, _badgewidth, _badgeheight, hex)',
        '_moveAlphaSlider(alpha, _badgeheight)',
        '_moveHueSlider(h, _badgeheight)',
        '_drawColorBadge(h, s, l, _badgewidth, _badgeheight)',
      ];
    }

    connectedCallback() {
      super.connectedCallback();
      this._select = this._select.bind(this);
      this._grabEnd = this._grabEnd.bind(this);
      if (this.colorString === undefined) {
        if (this.default) {
          this.colorString = this.default;
        } else {
          this.random();
        }
      }
    }

    _resizeBadge() {
      super._resizeBadge();
      const box = this.$.alphaBadge.getBoundingClientRect();
      this._sliderwidth = Math.round(box.width);
    }

    _drawBadge() {
    }

    _drawColorBadge(h, s, l, width, height) {
      if (h === undefined || s === undefined || l === undefined) {
        return;
      }
      if (width === undefined || height === undefined) {
        setTimeout( () => {
          this._resizeBadge();
        }, 0);
        return;
      }
      if (this._context === undefined) {
        this._context = this.$.badge.getContext("2d");
      }
      this._resizeBadge();
      this._context.clearRect(0, 0, width, height);

      let gradient = this._context.createLinearGradient(0, 0, width, 1);
      gradient.addColorStop(0, 'hsl(0,100%,100%)');
      gradient.addColorStop(1, `hsl(${h},100%,50%)`);

      this._context.fillStyle = gradient;
      this._context.fillRect(0, 0, width, height);

      gradient = this._context.createLinearGradient(0, 0, 1, height);
      gradient.addColorStop(0, 'rgba(0,0,0,0)');
      gradient.addColorStop(1, 'rgba(0,0,0,1)');

      this._context.fillStyle = gradient;
      this._context.fillRect(0, 0, width, height);
    }

    _drawAlpha(h, width, height) {
      if (h === undefined) {
        return;
      }
      if (width === undefined || height === undefined) {
        setTimeout( () => {
          this._resizeBadge();
        }, 0);
        return;
      }
      if (this._alphacontext === undefined) {
        this._alphacontext = this.$.alpha.getContext("2d");
      }

      this._alphacontext.clearRect(0, 0, width, height);

      let gradient = this._alphacontext.createLinearGradient(0, 0, 1, height);
      gradient.addColorStop(0, `hsl(${h},100%,50%)`);
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      this._alphacontext.fillStyle = gradient;
      this._alphacontext.fillRect(0, 0, width, height);
    }

    _drawSelector(element, x, y, hex) {
      element.style.transform = `translate(${Math.round(x || 0)}px,${Math.round(y || 0)}px)`;
      if (hex !== undefined) {
        element.style.background = hex;
      }
    }

    _moveHueSlider(h, height) {
      if (h === undefined || height === undefined) {
        return;
      }
      this._drawSelector(this.$.hueSlider, 0, height * (h || 0) / 360);
    }

    _moveAlphaSlider(alpha, height) {
      if (alpha === undefined || height === undefined) {
        return;
      }
      this._drawSelector(this.$.alphaSlider, 0, (1 - alpha) * height);
    }

    _moveColorPin(s, l, width, height, hex) {
      if (s === undefined || l === undefined || width === undefined || height === undefined || hex === undefined) {
        return;
      }
      this._drawSelector(this.$.colorPin, width * s, height * (1 - l), hex);
    }

    _drawHue(width, height) {
      if (this._huecontext === undefined) {
        this._huecontext = this.$.hue.getContext("2d");
      }

      this._huecontext.clearRect(0, 0, width, height);

      let gradient = this._huecontext.createLinearGradient(0, 0, 1, height);

      for (let step = 0; step < 360; step += 30) {
        gradient.addColorStop(step/360, `hsl(${step},100%,50%)`);
      }
      gradient.addColorStop(1, `hsl(0,100%,50%)`);
      this._huecontext.fillStyle = gradient;
      this._huecontext.fillRect(0, 0, width, height);
    }

    _grabStart(e) {
      if (!(e && e.target)) {
        return;
      }
      e.target.classList.add('grabbing');
      e.target.addEventListener('mousemove', this._select, {capture: false, passive: true});
      e.target.addEventListener('touchmove', this._select, {capture: false, passive: true});
      e.target.addEventListener('mouseup', this._grabEnd, {capture: false, passive: true});
      e.target.addEventListener('mouseleave', this._grabEnd, {capture: false, passive: true});
      e.target.addEventListener('touchend', this._grabEnd, {capture: false, passive: true});
      this._select(e);
    }

    _grabEnd(e) {
      if (!(e && e.target)) {
        return;
      }
      this._select(e);
      e.target.classList.remove('grabbing');
      e.target.removeEventListener('mousemove', this._select, {capture: false, passive: true});
      e.target.removeEventListener('touchmove', this._select, {capture: false, passive: true});
      e.target.removeEventListener('mouseup', this._grabEnd, {capture: false, passive: true});
      e.target.removeEventListener('mouseleave', this._grabEnd, {capture: false, passive: true});
      e.target.removeEventListener('touchend', this._grabEnd, {capture: false, passive: true});
    }

    _select(e) {
      // if (!(e && e.target && e.target.classList.contains('grabbing'))) {
      //   return;
      // } else if (e && e.type) {
      //   e.target.removeEventListener(e.type, this._select, {capture: false, passive: true});
      // }
      console.log(e);
      let property = e.target.getAttribute('prop');
      if (!property) {
        if (e.path) {
          for (let i = 0; i < e.path.length; i++) {
            if (e.path[i].classList && e.path[i].classList.contains('slider')) {
              property = e.path[i].getAttribute('prop');
              break;
            }
          }
        } else if (e.target && e.target.classList && e.target.classList.contains('slider')) {
          property = e.target.getAttribute('prop');
        }
      }

      let rect, s, l, h, alpha;
      switch (property) {
        case 'alpha':
          rect = this.$.alpha.getBoundingClientRect();
          alpha = (1 - Math.round(100*(e.clientY - rect.top) / rect.height)/100);
          if (alpha <= 1 && alpha >= 0) {
            this.alpha = alpha;
          }
          return;
        case 'hue':
          rect = this.$.hue.getBoundingClientRect();
          h = Math.round(360 * (e.clientY - rect.top) / rect.height);
          console.log(h);
          if (h <= 360 && h >= 0) {
            this.h = h;
          }
          return;
        default:
          console.log(property);
          rect = this.$.badge.getBoundingClientRect();
          s = +((e.clientX - rect.left) / rect.width).toFixed((this.hslPrecision || 0) + 2);
          l = +(1 - (e.clientY - rect.top) / rect.height).toFixed((this.hslPrecision || 0) + 2);
          if (s <= 1 && s >= 0 && l <= 1 && l >= 0) {
            this.setProperties({
              h: this.h,
              s: s,
              l: l
            });
          } else if (s <= 1 && s >= 0) {
            this.s = s;
          } else if (l <= 1 && l >= 0) {
            this.l = l;
          }
          return;
      }
    }
  }
</script>

<dom-module id="color-element">
  <script>
  /**
  * `<color-element>` adds a color selector to your page using Polymer.
  *
  *   ```html
  *     <color-element value="{{color}}"></color-element>
  *   ```
  *
  * For example if you clamp on `hours`, you can round `color` and `value` to `00:00:00`. If you set `clamp="day"` you hide the day-selection.
  *
  * The following custom properties and mixins are also available for styling:
  *
  * @customElement
  * @polymer
  *
  * @appliesMixin ColorElementPattern
  *
  * @demo demo/color-picker.html
  **/
    class ColorElement extends ColorElementPattern(Polymer.Element) { // eslint-disable-line no-undef

      static get is() {
        return 'color-element';
      }

      static get template() {
        return `
          <style include="${this.styleToInclude}">
            ${this.styleTemplate}
          </style>
          ${this.colorElementTemplate}
        `;
      }

      static get properties() {
        return {
          /**
           * is true when the value is not undefined
           */
          _valueIsSet: {
            type: Boolean,
            value: false
          }
        };
      }

      static get observers() {
        return [
          '_computeValueIsSet(colorString)'
        ];
      }

      _computeValueIsSet(value) {
        this._valueIsSet = value !== undefined;
      }

    }
    window.customElements.define(ColorElement.is, ColorElement);
  </script>
</dom-module>
