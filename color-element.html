<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/mixins/gesture-event-listeners.html">

<link rel="import" href="../property-mixins/range-mixin.html">
<link rel="import" href="../input-picker-pattern/input-picker-shared-style.html">

<link rel="import" href="../color-input/color-badge.html">

<script>
  /**
   * Mixin for color-element
   *
   * @mixinFunction
   * @polymer
   */
  const ColorElementPattern = superClass => class extends superClass { // eslint-disable-line no-unused-vars, no-undef

    static get styleTemplate() {
      return `
        ${super.styleTemplate || ''}
        #colorElement {
          color: var(--input-picker-color);
          background-color: var(--input-picker-background);
          border-radius: var(--color-element-badge-radius, var(--input-picker-border-radius, 6px));
          padding: var(--input-picker-padding);
          @apply --input-picker;
          display: -ms-inline-flexbox;
          display: -webkit-inline-flex;
          display: inline-flex;
          flex-flow: column nowrap;
          @apply --color-element;
        }
        #colorElement .selectors {
          display: inline-flex;
          flex-direction: row;
          position: relative;
          box-sizing: content-box;
        }
        #colorElement .selectors > * {
          position: relative;
          margin-left: var(--input-picker-padding);
          height: var(--color-element-height, 184px);
          width: var(--color-slider-width, 16px);
          background: transparent;
          cursor: pointer;
          box-sizing: content-box;
        }
        #colorElement .selectors > :first-child,
        #colorElement .selectors > :first-child canvas {
          border-radius: var(--color-element-badge-radius, var(--input-picker-border-radius, 6px)) 0px 0px 0px !important;
        }
        #colorElement .selectors > :last-child,
        #colorElement .selectors > :last-child canvas {
          border-radius: 0px var(--color-element-badge-radius, var(--input-picker-border-radius, 6px)) 0px 0px !important;
        }
        #colorElement .badge {
          margin-left: 0;
          background: transparent;
          box-shadow: none;
          cursor: crosshair;
          width: var(--color-element-width, 184px);
        }
        #colorElement .selector {
          position: absolute;
          box-sizing: border-box;
          border: thin solid currentColor;
          cursor: var(--color-selector-cursor, pointer);
          pointer-events: none;
          transition-property: background-color;
          transition-duration: var(--input-transition-duration, 250ms);
          transition-timing-function: var(--input-transition-timing-function, cubic-bezier(0.6, 1, 0.2, 1));
          mix-blend-mode: exclusion;
        }
        #colorElement canvas {
          pointer-events: all;
          position: absolute;
          top: 0;
          left: 0;
        }
        #colorElement .slider {
          top: 0;
          left: 0;
          padding: var(--color-slider-padding, 2px);
          width: 100%;
          border-radius: 2px;
          transform: translateY(-50%);
        }
        #colorElement .pin {
          top: 0;
          left: 0;
          padding: var(--color-pin-radius, 3px);
          border-radius: 50%;
          transform: translate(-50%, -50%);
          transition-property: opacity, background-color;
        }
        canvas.active ~ .pin {
          background-color: rgba(0,0,0,0.25);
        }
        #colorElement #alphaBadge {
          background: #fff;
        }
        #colorElement #buttons {
          display: inline-flex;
          flex-direction: row;
          position: relative;
          align-items: flex-end;
          align-self: stretch;
          flex: 0 0 auto;
          margin-top: var(--input-picker-padding);
        }
        #colorElement #buttons #formats {
          align-self: stretch;
        }
        canvas.active:hover ~ .pin {
          opacity: 0;
        }
        #colorElement .pin:focus {
          mix-blend-mode: normal;
        }
        canvas.active ~ .pin:focus {
          background: transparent;
        }
        #alpha.active,
        #hue.active {
          cursor: none;
        }
        @media (pointer:coarse) {
          canvas.active ~ .pin {
            opacity: 1;
          }
        }
      `;
    }

    static get colorElementTemplate() {
      return `
        <div id="colorElement">
          <div class="selectors">
            <div id="saturationBadge" class="badge">
              <canvas id="saturation" prop="color" width$="[[_saturationwidth]]" height$="[[_saturationheight]]" on-track="_onTrack" on-down="_onDown" on-tap="_onTap"></canvas>
              <button id="colorPin" prop="color" hidden$=[[!_valueIsSet]] class="selector pin" on-focus="_onFocusButton" on-keydown="_onKeyDown"></button>
            </div>
            <div id="alphaBadge" class="transparency">
              <canvas id="alpha" prop="alpha" width$="[[_sliderwidth]]" height$="[[_saturationheight]]" on-track="_onTrack" on-down="_onDown" on-tap="_onTap"></canvas>
              <button id="alphaSlider" class="selector slider" prop="alpha" on-focus="_onFocusButton" on-keydown="_onKeyDown"></button>
            </div>
            <div>
              <canvas id="hue" prop="hue" width$="[[_sliderwidth]]" height$="[[_saturationheight]]" on-track="_onTrack" on-down="_onDown" on-tap="_onTap"></canvas>
              <button id="hueSlider" class="selector slider" prop="hue" on-focus="_onFocusButton" on-keydown="_onKeyDown"></button>
            </div>
          </div>
          <div id="buttons">
            ${this.buttonTemplate}
          <div>
        </div>
      `
    }

    /**
     * template for control buttons
     * @type {string}
     */
    static get buttonTemplate() {
      return `
        <div style="flex:1;"></div>
        <button class="icon random" on-click="random"><svg viewBox="0 0 24 24"><g><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></g></svg></button>
        ${super.buttonTemplate || ''}
      `;
    }

    static get properties() {
      return {
        _sliderwidth: Number,

        _saturationheight: Number,

        _saturationwidth: Number
      };
    }

    static get observers() {
      return [
        '_drawHue(_sliderwidth, _saturationheight)',
        '_drawAlpha(h, _sliderwidth, _saturationheight)'
      ];
    }

    connectedCallback() {
      super.connectedCallback();
      if (this.colorString === undefined) {
        if (this.default) {
          this.colorString = this.default;
        } else {
          this.random();
        }
      }
    }

    _resizeBadge() {
      super._resizeBadge();
      const slider = this.$.alphaBadge.getBoundingClientRect();
      const sliderwidth = Math.round(slider.width);
      const saturation = this.$.saturationBadge.getBoundingClientRect();

      this.setProperties({
        _saturationwidth: Math.round(saturation.width),
        _saturationheight: Math.round(saturation.height),
        _sliderwidth: sliderwidth
      });
    }

    _drawBadge(value) {
      super._drawBadge(value);

      if (this._saturationcontext === undefined) {
        this._saturationcontext = this.$.saturation.getContext("2d");
      }
      const width = this._saturationwidth,
        height = this._saturationheight;

      this._saturationcontext.clearRect(0, 0, width, height);

      let gradient = this._saturationcontext.createLinearGradient(0, 0, width, 1);
      gradient.addColorStop(0, 'hsl(0,100%,100%)');
      gradient.addColorStop(1, `hsl(${Math.round(this.h || 0)},100%,50%)`);

      this._saturationcontext.fillStyle = gradient;
      this._saturationcontext.fillRect(0, 0, width, height);

      gradient = this._saturationcontext.createLinearGradient(0, 0, 1, height);
      gradient.addColorStop(0, 'rgba(0,0,0,0)');
      gradient.addColorStop(1, 'rgba(0,0,0,1)');

      this._saturationcontext.fillStyle = gradient;
      this._saturationcontext.fillRect(0, 0, width, height);

      this._drawSelector(this.$.alphaSlider, 0, (1 - (this.alpha || 0)) * height);
      this._drawSelector(this.$.hueSlider, 0, height * (this.h || 0) / 360);

      const c = this.s * (this.l < .5 ? this.l : 1 - this.l),
        s = ((2 * c) / (this.l + c)) || 0,
        v = 1 - (this.l + c);

      this._drawSelector(this.$.colorPin, width * s, height * v);
    }

    _drawSelector(element, x, y) {
      element.style.left = `${Math.round(x || 0)}px`;
      element.style.top = `${Math.round(y || 0)}px`;
    }

    _drawAlpha(h, width, height) {
      if (width === undefined || height === undefined) {
        setTimeout( () => {
          this._resizeBadge();
        }, 0);
        return;
      }
      if (this._alphacontext === undefined) {
        this._alphacontext = this.$.alpha.getContext("2d");
      }

      this._alphacontext.clearRect(0, 0, width, height);

      let gradient = this._alphacontext.createLinearGradient(0, 0, 1, height);
      gradient.addColorStop(0, `hsla(${Math.round(h || 0)}, 100%, 50%, 1)`);
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      this._alphacontext.fillStyle = gradient;
      this._alphacontext.fillRect(0, 0, width, height);
    }

    _drawHue(width, height) {
      if (width === undefined || height === undefined) {
        setTimeout( () => {
          this._resizeBadge();
        }, 0);
        return;
      }
      if (this._huecontext === undefined) {
        this._huecontext = this.$.hue.getContext("2d");
      }

      this._huecontext.clearRect(0, 0, width, height);

      let gradient = this._huecontext.createLinearGradient(0, 0, 1, height);

      for (let step = 0; step < 360; step += 30) {
        gradient.addColorStop(step/360, `hsl(${step},100%,50%)`);
      }
      gradient.addColorStop(1, `hsl(0,100%,50%)`);
      this._huecontext.fillStyle = gradient;
      this._huecontext.fillRect(0, 0, width, height);
    }

    _checkSelectorForProperty(e, id) {
      if (e.target.hasAttribute('prop')) {
        return e.target.getAttribute('prop');
      } else if (id && this.$[id] && this.$[id].hasAttribute('prop')) {
        return this.$[id].getAttribute('prop');
      } else if (e.path) {
        for (let i = 0; i < e.path.length; i++) {
          if (e.path[i] && e.path[i].hasAttribute && e.path[i].hasAttribute('prop')) {
            return e.path[i].getAttribute('prop');
          }
        }
      }
    }

    _getActiveCanvas() {
      switch (this._activeProperty) {
        case 'alpha':
          this._activeSelectionCanvas = this.$.alpha;
          break;
        case 'hue':
          this._activeSelectionCanvas = this.$.hue;
          break;
        default:
          this._activeSelectionCanvas = this.$.saturation;
      }
      this._activeSelectionRect = this._activeSelectionCanvas.getBoundingClientRect();
      this._activeSelectionCanvas.classList.add('active');
    }

    _onTrack(e) {
      if (!this._activeProperty) {
        this._activeProperty = this._checkSelectorForProperty(e);
      }
      if (!this._activeSelectionCanvas) {
        this._getActiveCanvas();
      }
      const rect = this._activeSelectionRect;
      let s, c, h, v, offsetX = e.detail.x || e.clientX, offsetY = e.detail.y || e.clientY;
      switch (this._activeProperty) {
        case 'alpha':
          offsetY -= rect.top;
          if (offsetY > rect.height) {
            offsetY = rect.height;
          } else if (offsetY < 0) {
            offsetY = 0;
          }
          this.alpha = +this._normalizedClamp((rect.height - offsetY) / rect.height).toFixed(2);
          this._drawSelector(this.$.alphaSlider, 0, offsetY);
          break;
        case 'hue':
          offsetY -= rect.top;
          if (offsetY > rect.height) {
            offsetY = rect.height;
          } else if (offsetY < 0) {
            offsetY = 0;
          }
          h = Math.round(360 * offsetY / rect.height);
          this.h = this._mathMod(h, 360);
          this._drawSelector(this.$.hueSlider, 0, offsetY);
          break;
        default:
          offsetX -= rect.left;
          if (offsetX > rect.width) {
            offsetX = rect.width;
          } else if (offsetX < 0) {
            offsetX = 0;
          }

          offsetY -= rect.top;
          if (offsetY > rect.height) {
            offsetY = rect.height;
          } else if (offsetY < 0) {
            offsetY = 0;
          }

          s = offsetX / rect.width;
          v = 1 - offsetY / rect.height;
          c = (2 - s) * v;

          this.setProperties({
            h: this.h || 0,
            s: c === 0 ? 0 : +(s * v / (c < 1 ? c : 2 - c)).toFixed(2),
            l: +(c/2).toFixed(2)
          });

          setTimeout(() => {
            this._drawSelector(this.$.colorPin, offsetX, offsetY);
          }, 0);
        }
        if (e.detail.state && e.detail.state === 'end') {
          this._onSelectEnd();
        }
      }

      _onDown(e) {
        this._onSelectEnd(e);
        this._onTrack(e);
      }

      _onTap(e) {
        this._onSelectEnd(e);
        this._onTrack(e);
        switch (this._activeProperty) {
          case 'alpha':
            this.$.alphaSlider.focus();
            break;
          case 'hue':
            this.$.hueSlider.focus();
            break;
          case 'color':
            this.$.colorPin.focus();
        }
        if (this._activeSelectionCanvas) {
          this._activeSelectionCanvas.classList.remove('active');
        }
        this._activeSelectionCanvas = null;
        this._activeSelectionRect = null;
      }

      _onFocusButton(e) {
        this._activeProperty = this._checkSelectorForProperty(e, e.target.id);
      }

      _onKeyDown(e) {
        if (this._activeProperty) {
          let switched, ev;
          switch (this._activeProperty) {
            case 'alpha':
              if (e.keyCode === 38) { // up
                this.alpha = window._numberUtilities._safeMult(Math.round(this.alpha*100 + 1), 0.01); switched = true;
              } else if (e.keyCode === 40) { // down
                this.alpha = window._numberUtilities._safeMult(Math.round(this.alpha*100 - 1), 0.01); switched = true;
              }
              break;
            case 'hue':
              if (e.keyCode === 38) { // up
                this.h = Math.round(this.h - 1); switched = true;
              } else if (e.keyCode === 40) { // down
                this.h = Math.round(this.h + 1); switched = true;
              }
              break;
            default:
              if (!this._activeSelectionRect) {
                this._activeSelectionRect = this.$.saturation.getBoundingClientRect();
                this._activeSelectionCanvas = this.$.saturation;
              }
              ev = {
                detail: this.$.colorPin.getBoundingClientRect()
              };

              ev.detail.x = ev.detail.x + ev.detail.width / 2;
              ev.detail.y = ev.detail.y + ev.detail.height / 2;
              if (e.keyCode === 38) { // up
                ev.detail.y -= (Math.round(this._activeSelectionRect.height / 100) || 1);
              } else if (e.keyCode === 40) { // down
                ev.detail.y += (Math.round(this._activeSelectionRect.height / 100) || 1);
              } else if (e.keyCode === 37) { // left
                ev.detail.x -= (Math.round(this._activeSelectionRect.width / 100) || 1);
              } else if (e.keyCode === 39) { // right
                ev.detail.x += (Math.round(this._activeSelectionRect.width / 100) || 1);
              } else {
                return;
              }
              this._onTrack(ev);
              switched = true;
          }
          if (switched) {
            e && e.stopPropagation && e.stopPropagation();
            e && e.preventDefault && e.preventDefault();
          }
        } else if (this.keyCode === 27) {
          document.activeElement.blur();
          this._onSelectEnd();
        }
      }

      _onSelectEnd() {
        if (this._activeSelectionCanvas) {
          this._activeSelectionCanvas.classList.remove('active');
        }
        this._activeSelectionCanvas = null;
        this._activeSelectionRect = null;
        this._activeProperty = null;
      }
    }
    window.ColorElementPattern = ColorElementPattern;
</script>

<dom-module id="color-element">
  <script>
  /**
  * `<color-element>` adds a color selector to your page using Polymer.
  *
  *   ```html
  *     <color-element value="{{color}}"></color-element>
  *   ```
  * Custom property | Description | Default
  * ----------------|-------------|----------
  * `--transparency-pattern` | background pattern for the transparency layer | linear-gradient(45deg, rgba(0,0,0,0.15) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.15) 75%, rgba(0,0,0,0.15)), linear-gradient(45deg, rgba(0,0,0,0.15) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.15) 75%, rgba(0,0,0,0.15)))
  * `--transparency-pattern-size` | size transparency pattern | 12px
  * `--color-element-badge-radius` | border-radius of the badge | --input-picker-border-radius, 6px
  * `--color-element-height` | height of the selector badge and the alpha- and the hue-slider| 184px
  * `--color-element-width` | width of the selector badge | 184px
  * `--color-slider-width` | width of the alpha- and the hue-slider | 16px
  * `--color-slider-padding` | padding of the alpha- and the hue-slider | 2px
  * `--color-pin-radius` | radius of the color pin | 3px
  * `--color-element` | mixin applied to the color element | {}
  *
  *  Have a look at [input-picker-pattern#input-shared-style](https://github.com/fooloomanzoo/input-picker-pattern#input-shared-style) to see the used style-properties.
  *
  * @customElement
  * @polymer
  *
  * @appliesMixin ColorElementPattern
  * @appliesMixin ColorBadgePattern
  *
  * @demo demo/color-picker.html
  **/
    class ColorElement extends Polymer.GestureEventListeners(ColorElementPattern(ColorBadgePattern(Polymer.Element))) { // eslint-disable-line no-undef

      static get is() {
        return 'color-element';
      }

      static get styleToInclude() {
        return `${super.styleToInclude || '' } input-picker-shared-style`;
      }

      static get template() {
        return `
          <style include="${this.styleToInclude}">
            ${this.styleTemplate}
          </style>
          ${this.colorElementTemplate}
        `;
      }

    }
    window.customElements.define(ColorElement.is, ColorElement);
  </script>
</dom-module>
