<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../color-input/color-badge.html">
<link rel="import" href="../text-input/text-input.html">

<script>
  /**
   * Mixin for color-element
   *
   * @appliesMixin ColorBadgePattern
   *
   * @mixinFunction
   * @polymer
   */
  const ColorElementPattern = superClass => class extends ColorBadgePattern(superClass) { // eslint-disable-line no-unused-vars, no-undef

    static get customStyleContent() {
      return `
        ${super.customStyleContent || ''}
        :host {
          display: inline-flex;
          -webkit-user-select: none;
          -moz-user-select: none;
          -ms-user-select: none;
          user-select: none;
          -webkit-tap-highlight-color:rgba(0,0,0,0);
          align-items: center;
          vertical-allign: unset;
        }
        #colorElement {
          display: inline-flex;
          flex-direction: column;
          background: var(--color-element-background, #f0f0f0);
        }
        #colorElement #selectors {
          display: inline-flex;
          flex-direction: row;
        }
        #colorElement #selectors > * {
          margin: var(--color-element-margin) var(--color-element-margin) var(--color-element-margin) 0;
        }
        #colorElement #saturation {
          cursor: crosshair;
          margin-left: var(--color-element-margin);
        }
        #colorElement #alpha,
        #colorElement #hue {
          cursor: -webkit-grab;
          cursor: grab;
        }
        #colorElement #alpha.grabbing,
        #colorElement #hue.grabbing {
          cursor: -webkit-grabbing;
          cursor: grabbing;
        }
        #lower {
          display: inline-flex;
          align-items: center;
        }
      `;
    }

    static get colorElementTemplate() {
      return `
        <div id="colorElement">
          <div id="selectors">
            <canvas id="saturation" width="208" height="184" on-mousedown="_grabStart" on-touchstart="_grabStart"></canvas>
            <div class="transparency">
              <canvas id="alpha" width="16" height="184" on-mousedown="_grabStart" on-touchstart="_grabStart"></canvas>
            </div>
            <canvas id="hue" width="16" height="184" on-mousedown="_grabStart" on-touchstart="_grabStart"></canvas>
          </div>
          <div id="lower">
            ${this.colorBadgeTemplate}
          </div>
        </div>
      `
    }

    static get colorBadgeTemplate() {
      return `
        ${super.colorBadgeTemplate}
      `

    }

    static get colorBadgeSlotTemplate() {
      return ''
    }

    connectedCallback() {
      super.connectedCallback();
      this.addEventListener('contextmenu', this._onContextMenu.bind(this), false);
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      this.removeEventListener('contextmenu', this._onContextMenu.bind(this), false);
    }

    /**
     * renderColors the current view (manually).
     */
    _drawSelector(h, s, l) {
      let context = this.$.saturation.getContext("2d");
      let rect = this.$.saturation.getBoundingClientRect();

      let width = rect.width;
      let height = rect.height;

      context.clearRect(0, 0, width, height);

      let gradient = context.createLinearGradient(0, 0, width, 1);
      gradient.addColorStop(0, 'hsl(0,100%,100%)');
      gradient.addColorStop(1, `hsl(${h},100%,50%)`);

      context.fillStyle = gradient;
      context.fillRect(0, 0, width, height);

      gradient = context.createLinearGradient(0, 0, 1, height);
      gradient.addColorStop(0, 'rgba(0,0,0,0)');
      gradient.addColorStop(1, 'rgba(0,0,0,1)');

      context.fillStyle = gradient;
      context.fillRect(0, 0, width, height);
      const x = width * s,
       y = height * (1 - l);
      this._drawCircle(context, x, y);
    }

    _drawCircle(context, x, y) {
      context.beginPath();
      context.arc(x, y, 3, 0, 2*Math.PI);
      context.closePath();
      context.lineWidth = 1.5;
      context.strokeStyle = '#fff';
      context.stroke();
    }

    _fillRect(elem, value) {
      const context = elem.getContext("2d"),
        rect = elem.getBoundingClientRect(),
        width = rect.width,
        height = rect.height;

      context.clearRect(0, 0, width, height);
      context.fillStyle = value;
      context.fillRect(0, 0, width, height);
    }

    _drawHue(h, s, l) {
      let context = this.$.hue.getContext("2d");
      let rect = this.$.hue.getBoundingClientRect();

      let width = rect.width;
      let height = rect.height;

      context.clearRect(0, 0, width, height);

      let gradient = context.createLinearGradient(0, 0, 1, height);

      for (let step = 0; step < 360; step += 30) {
        gradient.addColorStop(step/360, `hsl(${step},100%,50%)`);
      }
      gradient.addColorStop(1, `hsl(0,100%,50%)`);
      context.fillStyle = gradient;
      context.fillRect(0, 0, width, height);

      const y = height * h / 360;
      this._drawSlider(context, width, y);
    }

    _drawAlpha(h, alpha) {

      let context = this.$.alpha.getContext("2d");
      let rect = this.$.alpha.getBoundingClientRect();

      let width = rect.width;
      let height = rect.height;

      context.clearRect(0, 0, width, height);

      let gradient = context.createLinearGradient(0, 0, 1, height);
      gradient.addColorStop(0, `hsl(${h},100%,50%)`);
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      context.fillStyle = gradient;
      context.fillRect(0, 0, width, height);
      const y = (1 - alpha) * height;
      this._drawSlider(context, width, y);
      this.alpha = alpha;
    }

    _drawSlider(context, width, y) {
      context.beginPath();
      y -= 2;
      context.moveTo(0, y);
      context.lineTo(width, y);
      y += 3;
      context.moveTo(0, y);
      context.lineTo(width, y);
      context.closePath();
      context.lineWidth = 1.5;
      context.strokeStyle = '#fff';
      context.stroke();
    }

    _fixColor() {
      console.log('_fixColor', this._selectedHsv);
      if (this._selectedHsv) {
        const rgb = this.hsvToRgb(this._selectedHsv);
        if (this._arrayEqual(this.rgb, rgb) === false) {
          this.set('rgb', rgb);
          this._drawSelectedColor(this.hsv, this.alpha);
          this._drawSaturation(this.hsv);
        }
        this.close();
      }
    }

    _resetColor() {
      if (!(Array.isArray(this.hsv) && this.hsv.length === 3)) {
        return;
      }
      this._drawSelectedColor(this.hsv, this.alpha);
      this._drawSaturation(this.hsv);
    }

    _grabStart(e) {
      if (!(e && e.target)) {
        return;
      }
      e.target.classList.add('grabbing');
      e.target.addEventListener('mousemove', this._select.bind(this), {capture: false, passive: true});
      e.target.addEventListener('touchmove', this._select.bind(this), {capture: false, passive: true});
      e.target.addEventListener('mouseup', this._grabEnd.bind(this), {capture: false, passive: true});
      e.target.addEventListener('mouseleave', this._grabEnd.bind(this), {capture: false, passive: true});
      e.target.addEventListener('touchend', this._grabEnd.bind(this), {capture: false, passive: true});
      this._select(e);
    }

    _grabEnd(e) {
      if (!(e && e.target)) {
        return;
      }
      this._select(e);
      e.target.classList.remove('grabbing');
      e.target.removeEventListener('mousemove', this._select.bind(this), {capture: false, passive: true});
      e.target.removeEventListener('touchmove', this._select.bind(this), {capture: false, passive: true});
      e.target.removeEventListener('mouseup', this._grabEnd.bind(this), {capture: false, passive: true});
      e.target.removeEventListener('mouseleave', this._grabEnd.bind(this), {capture: false, passive: true});
      e.target.removeEventListener('touchend', this._grabEnd.bind(this), {capture: false, passive: true});
    }

    _select(e) {
      if (!(e && e.target && e.target.classList.contains('grabbing'))) {
        return;
      } else if (e && e.type) {
        e.target.removeEventListener(e.type, this._select.bind(this), {capture: false, passive: true});
      }

      const rect = e.target.getBoundingClientRect(),
      width = rect.width,
      height = rect.height,
      elemLeft = rect.left,
      elemTop = rect.top,
      property = e.target.getAttribute('id');
      const hsv = [];
      for (let i = 0; i < this._selectedHsv.length; i++) {
        hsv.push(this._selectedHsv[i] || 0);
      }
      let alpha = this.alpha;
      switch (property) {
        case 'alpha':
          alpha = +(1 - (e.clientY - elemTop) / height).toFixed(2);
          alpha = (alpha >= 0 && alpha <= 1) ? alpha : (this.alpha || 1);
          break;
        case 'saturation':
          s = +(((e.clientX - elemLeft) / width).toFixed(3));
          s = s > 1 ? 1 : s;
          s = s < 0 ? 0 : s;
          l = +((1 - (e.clientY - elemTop) / height).toFixed(3));
          l = l > 1 ? 1 : l;
          l = l < 0 ? 0 : l;
          this._drawHue(h, s, l);
          this._drawSelector(h, s, l);
          break;
        case 'hue':
          h = Math.round(360 * (e.clientY - elemTop) / height);
          h = h > 360 ? 360 : h;
          h = h < 0 ? 0 : h;
          this._drawHue(h, s, l);
          this._drawSelector(h, s, l);
          break;
      }
      this.set('_selectedHsv', hsv);
      this.alpha = alpha;
      this._drawAlpha(h, alpha);
    }

    _onContextMenu(e) {
      if (e && e.preventDefault) {
        e.preventDefault();
      }
      this.random()
    }
  }
</script>

<dom-module id="color-element">
  <script>
  /**
  * `<color-element>` adds a color selector to your page using Polymer.
  *
  *   ```html
  *     <color-element value="{{color}}"></color-element>
  *   ```
  *
  * For example if you clamp on `hours`, you can round `color` and `value` to `00:00:00`. If you set `clamp="day"` you hide the day-selection.
  *
  * The following custom properties and mixins are also available for styling:
  *
  * Custom property | Description | Default
  * ----------------|-------------|----------
  * `--color-element-margin` | margin of the single color-element | `0px`
  * `--color-element-background` | background-color of the color-element | `#f0f0f0`
  *
  * @customElement
  * @polymer
  *
  * @appliesMixin ColorElementPattern
  *
  * @demo demo/color-picker.html
  **/
    class ColorElement extends ColorElementPattern(Polymer.Element) { // eslint-disable-line no-undef

      static get is() {
        return 'color-element';
      }

      static get template() {
        return `
          ${this.styleTemplate}
          ${this.colorElementTemplate}
        `
      }

    }
    window.customElements.define(ColorElement.is, ColorElement);
  </script>
</dom-module>
